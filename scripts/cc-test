#!/bin/bash
#
# cc-test - Test wrapper script for Command Center
#
# Usage: cc-test <test-command> [args...]
#
# Automatically tracks test status for the current branch by:
# 1. Detecting current git branch
# 2. Recording test start time
# 3. Running the test command and capturing output
# 4. Capturing exit code
# 5. Parsing test output to extract pass/fail counts
# 6. Updating test status via `ccc test parse`
# 7. Preserving original exit code

set -o pipefail

# Check arguments
if [ $# -lt 1 ]; then
    echo "Usage: cc-test <test-command> [args...]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  cc-test npm test" >&2
    echo "  cc-test pytest" >&2
    echo "  cc-test go test ./..." >&2
    exit 1
fi

# Auto-detect current branch
BRANCH_NAME=$(git branch --show-current 2>/dev/null)

if [ -z "$BRANCH_NAME" ]; then
    echo "Error: Not in a git repository or not on a branch" >&2
    exit 1
fi

# Record start time
START=$(date +%s)

# Create temp file for output
TMPFILE=$(mktemp)
trap "rm -f $TMPFILE" EXIT

# Run the test command
# Capture both stdout/stderr and exit code
set +e
"$@" 2>&1 | tee "$TMPFILE"
EXIT_CODE=$?
set -e

# Record end time and calculate duration
END=$(date +%s)
DURATION=$((END - START))

# Determine status
if [ $EXIT_CODE -eq 0 ]; then
    STATUS="passing"
else
    STATUS="failing"
fi

# Parse output and update test status
ccc test parse "$BRANCH_NAME" "$TMPFILE" --duration "$DURATION" --status "$STATUS" 2>/dev/null || {
    echo "Warning: Failed to parse test output for branch '$BRANCH_NAME'" >&2
    # Fallback: just update with basic status
    ccc test update "$BRANCH_NAME" --status "$STATUS" --duration "$DURATION" 2>/dev/null || true
}

# Exit with original exit code
exit $EXIT_CODE
